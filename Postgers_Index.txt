Типы индексов:
Кластерные(может быть только один в таблице)(чаще всего это первичный ключ) 
	-С упорядоченным физическим хранением данных
	-Без физического упорядочивания
Некластерные
	- Порядоок хранения данных не связан с индексными ключами
	
Кластеризованный индекс хранит реальные строки данных в листьях индекса(строка данных связанная со 
значением ключа хранится в самом индексе). Данные отсортированы по возрост или убыв поэтому индек может быть только один.

Таблица не имеющая кластеризованного индекса называется кочей.

листья некаластеризованного индекса содержат только те столбцы(ключевые) по которым определен данный индекс, а так же 
содержит указатели с реальными данными в таблице. Это означает что системе будет необходима дполнительная операция дл обнаружения требуемых данных.


Составной индекс- может включить до 16 стобцов в индекс, общая длина до 900байт

Уникальный индекс - когда указываем первичный ключ и задаём уникальность значения, субд автоматически создаёт уникальный кластеризованный индекс

Покрывающий индекс - хз

---------------------------------------------------

Основные структуры данных, используемые для индексов:

a) B-дерево (B-tree)
Описание: Сбалансированное дерево, где каждый узел может содержать множество ключей и дочерних узлов.

Применение: Используется для индексов по умолчанию в большинстве СУБД (PostgreSQL, MySQL, Oracle).

Преимущества:

Поддерживает быстрый поиск, вставку и удаление.

Эффективен для диапазонных запросов (например, BETWEEN, > , <).

Недостатки: Требует обновления при изменении данных, что может замедлять операции INSERT, UPDATE, DELETE.

b) B+-дерево (B-plus tree)
Описание: Модификация B-дерева, где все данные хранятся только в листьях, а внутренние узлы содержат только ключи для навигации.

Применение: Используется в MySQL (InnoDB), PostgreSQL.

Преимущества:

Листья связаны в виде списка, что упрощает диапазонные запросы.

Эффективен для операций чтения.

Недостатки: Как и B-дерево, требует обновления при изменении данных.

c) Хэш-индекс (Hash index)
Описание: Использует хэш-функции для быстрого поиска по точному совпадению.

Применение: Используется в PostgreSQL, MySQL (для MEMORY-таблиц).

Преимущества:

Очень быстрый поиск по точному совпадению.

Недостатки:

Не поддерживает диапазонные запросы.

Требует перестройки при изменении данных.

d) GiST (Generalized Search Tree)
Описание: Универсальная структура для работы с различными типами данных (геопространственные данные, текстовые данные и т.д.).

Применение: Используется в PostgreSQL для полнотекстового поиска, геоданных и других сложных типов данных.

Преимущества:

Гибкость: поддерживает множество типов данных.

Недостатки: Может быть менее эффективным для простых запросов.

e) GIN (Generalized Inverted Index)
Описание: Используется для индексации составных данных, таких как массивы, JSON или полнотекстовый поиск.

Применение: PostgreSQL.

Преимущества:

Эффективен для поиска по составным данным.

Недостатки: Может быть медленным для операций записи.

f) SP-GiST (Space-Partitioned Generalized Search Tree)
Описание: Оптимизирован для работы с пространственными данными и данными, которые можно разделить на непересекающиеся области.

Применение: PostgreSQL.

Преимущества:

Эффективен для специализированных задач, таких как геопространственные данные.

Недостатки: Не подходит для общих задач.

g) R-дерево (R-tree)
Описание: Используется для индексации многомерных данных, таких как геопространственные объекты.

Применение: PostgreSQL (через PostGIS), MySQL.

Преимущества:

Эффективен для геопространственных запросов.

Недостатки: Сложность поддержки и обновления.

AVL-дерево:

Описание: Двоичное дерево поиска, где для каждого узла высота левого и правого поддеревьев отличается не более чем на 1.

Балансировка: Использует повороты (левые, правые, двойные) для поддержания баланса.

Преимущества: Гарантирует строгую сбалансированность, что обеспечивает быстрый поиск.

Недостатки: Требует частых операций балансировки, что может замедлять вставку и удаление.

Красно-черное дерево (Red-Black Tree):

Описание: Двоичное дерево поиска, где каждый узел имеет дополнительный атрибут — цвет (красный или черный). Цвета используются для поддержания баланса.

Балансировка: Использует перекрашивание узлов и повороты.

Преимущества: Менее строгая балансировка, чем у AVL-дерева, но более эффективна для операций вставки и удаления.

Недостатки: Немного менее сбалансировано, чем AVL-дерево, но все же обеспечивает время выполнения операций за O(log n).

B-дерево (B-tree):

Описание: Сбалансированное дерево, где каждый узел может содержать множество ключей и дочерних узлов.

Балансировка: Поддерживает баланс за счет разделения и слияния узлов.

Преимущества: Эффективно для работы с дисковыми структурами данных (например, в базах данных).

Недостатки: Сложнее в реализации, чем двоичные деревья.

B+-дерево (B-plus tree):

Описание: Модификация B-дерева, где все данные хранятся только в листьях, а внутренние узлы содержат только ключи для навигации.

Балансировка: Аналогична B-дереву.

Преимущества: Эффективен для диапазонных запросов и работы с большими объемами данных.

Недостатки: Требует больше памяти для хранения указателей.

AA-дерево (Arne Andersson Tree):

Описание: Упрощенная версия красно-черного дерева.

Балансировка: Использует уровни (levels) вместо цветов.

Преимущества: Проще в реализации, чем красно-черное дерево.

Недостатки: Менее распространено.

Splay-дерево (Splay Tree):

Описание: Саморегулирующееся дерево, где недавно доступные элементы перемещаются ближе к корню.

Балансировка: Не гарантирует строгой сбалансированности, но обеспечивает амортизированное время выполнения операций за O(log n).

Преимущества: Эффективно для задач с локальностью данных.

Недостатки: Не подходит для задач, где требуется строгая сбалансированность.
