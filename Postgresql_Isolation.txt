Уровни изоляции (Isolation Levels) в базах данных определяют, как транзакции взаимодействуют друг с другом, особенно в условиях параллельного выполнения. Они контролируют видимость изменений, сделанных одной транзакцией, для других транзакций. Уровни изоляции помогают балансировать между производительностью и согласованностью данных.

1. Проблемы, которые решают уровни изоляции
При параллельном выполнении транзакций могут возникать следующие проблемы:

Грязное чтение (Dirty Read): Транзакция читает незафиксированные (неподтверждённые) изменения другой транзакции.

Неповторяющееся чтение (Non-Repeatable Read): Транзакция повторно читает данные и обнаруживает, что они изменились (другая транзакция изменила их).

Фантомное чтение (Phantom Read): Транзакция повторно выполняет запрос и обнаруживает новые строки, добавленные другой транзакцией.

Потерянное обновление (Lost Update): Две транзакции одновременно изменяют одни и те же данные, и одно из изменений теряется.

2. Уровни изоляции в SQL-стандарте
Стандарт SQL (ANSI/ISO) определяет четыре уровня изоляции:

a) Read Uncommitted (Чтение незафиксированных данных)
Описание: Самая низкая степень изоляции. Транзакции видят незафиксированные изменения других транзакций.

Проблемы:

Грязное чтение (Dirty Read).

Неповторяющееся чтение (Non-Repeatable Read).

Фантомное чтение (Phantom Read).

Использование: Редко используется, так как может приводить к несогласованности данных.

b) Read Committed (Чтение зафиксированных данных)
Описание: Транзакции видят только зафиксированные изменения других транзакций.

Проблемы:

Неповторяющееся чтение (Non-Repeatable Read).

Фантомное чтение (Phantom Read).

Использование: По умолчанию во многих СУБД (например, PostgreSQL, Oracle).

c) Repeatable Read (Повторяемое чтение)
Описание: Гарантирует, что данные, прочитанные в транзакции, не изменятся, если их повторно прочитать. Однако новые строки, добавленные другими транзакциями, могут быть видны (фантомное чтение).

Проблемы:

Фантомное чтение (Phantom Read).

Использование: Подходит для сценариев, где важно сохранять согласованность данных в рамках одной транзакции.

d) Serializable (Сериализуемый)
Описание: Самый строгий уровень изоляции. Транзакции выполняются так, как если бы они выполнялись последовательно (одна за другой).

Проблемы: Нет.

Использование: Обеспечивает полную изоляцию, но может снижать производительность из-за блокировок.

3. Уровни изоляции в PostgreSQL
PostgreSQL поддерживает все четыре уровня изоляции, но с некоторыми особенностями:

Read Uncommitted: В PostgreSQL ведёт себя как Read Committed, так как грязное чтение не поддерживается.

Read Committed: По умолчанию. Гарантирует, что транзакции видят только зафиксированные данные.

Repeatable Read: Гарантирует, что данные, прочитанные в транзакции, не изменятся. Фантомное чтение также предотвращается (в отличие от стандарта SQL).

Serializable: Полная изоляция. PostgreSQL использует механизм Serializable Snapshot Isolation (SSI) для предотвращения всех аномалий.

4. Примеры использования уровней изоляции
a) Read Committed
sql
Copy
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM accounts WHERE user_id = 1;
-- Другая транзакция может изменить данные до COMMIT.
COMMIT;
b) Repeatable Read
sql
Copy
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM accounts WHERE user_id = 1;
-- Данные не изменятся, даже если другая транзакция их обновит.
COMMIT;
c) Serializable
sql
Copy
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM accounts WHERE user_id = 1;
-- Полная изоляция, как если бы транзакции выполнялись последовательно.
COMMIT;
5. Как выбрать уровень изоляции?
Read Committed: Подходит для большинства сценариев, где не требуется строгая изоляция.

Repeatable Read: Используется, если важно, чтобы данные не изменялись в рамках одной транзакции.

Serializable: Применяется в критически важных системах, где требуется полная изоляция.

6. Производительность и блокировки
Чем строже уровень изоляции, тем больше накладных расходов на блокировки и управление транзакциями.

Serializable может значительно снижать производительность из-за большого количества блокировок и откатов транзакций.

7. Пример аномалий
a) Грязное чтение (Dirty Read)
Транзакция 1 изменяет данные, но не фиксирует их.

Транзакция 2 читает эти незафиксированные данные.

Транзакция 1 откатывается, но Транзакция 2 уже прочитала некорректные данные.

b) Неповторяющееся чтение (Non-Repeatable Read)
Транзакция 1 читает данные.

Транзакция 2 изменяет эти данные и фиксирует изменения.

Транзакция 1 повторно читает данные и видит изменения.

c) Фантомное чтение (Phantom Read)
Транзакция 1 выполняет запрос и получает набор строк.

Транзакция 2 добавляет новые строки и фиксирует изменения.

Транзакция 1 повторно выполняет запрос и видит новые строки.

Уровни изоляции — это мощный инструмент для управления согласованностью данных в многопользовательской среде. Выбор уровня зависит от требований к данным и производительности.




--

Изоляции

1. Изоляция транзакций
Изоляция транзакций регулирует, как изменения, сделанные одной транзакцией, видны другим транзакциям. Уровни изоляции (Read Uncommitted, Read Committed, Repeatable Read, Serializable) определяют степень видимости изменений и предотвращают аномалии, такие как грязное чтение, неповторяющееся чтение и фантомное чтение.

2. Блокировки в PostgreSQL
PostgreSQL использует механизм блокировок для управления доступом к данным на уровне:

Таблиц (table-level locks).

Строк (кортежей) (row-level locks).

Страниц (page-level locks).

Ячеек (cell-level locks, хотя это редко используется).

Блокировки необходимы для обеспечения согласованности данных при параллельном выполнении операций.

3. Типы блокировок
PostgreSQL поддерживает несколько типов блокировок, которые можно разделить на две категории:

Явные блокировки: Устанавливаются вручную с помощью SQL-команд.

Неявные блокировки: Устанавливаются автоматически при выполнении операций (например, INSERT, UPDATE, DELETE).

a) Блокировки таблиц
ACCESS SHARE: Устанавливается при операциях чтения (SELECT). Совместима с другими блокировками чтения.

ROW SHARE: Устанавливается при SELECT FOR UPDATE/SHARE. Совместима с ACCESS SHARE и ROW EXCLUSIVE.

ROW EXCLUSIVE: Устанавливается при INSERT, UPDATE, DELETE. Совместима с ACCESS SHARE и ROW SHARE.

SHARE UPDATE EXCLUSIVE: Устанавливается при VACUUM, CREATE INDEX CONCURRENTLY.

SHARE: Устанавливается при CREATE INDEX. Не совместима с ROW EXCLUSIVE.

SHARE ROW EXCLUSIVE: Устанавливается при ALTER TABLE, CREATE TRIGGER.

EXCLUSIVE: Блокирует все операции, кроме SELECT.

ACCESS EXCLUSIVE: Самая строгая блокировка. Устанавливается при DROP TABLE, TRUNCATE, VACUUM FULL.

Пример явной блокировки таблицы:

sql
Copy
LOCK TABLE my_table IN ACCESS EXCLUSIVE MODE;
b) Блокировки строк (кортежей)
FOR UPDATE: Блокирует строку для изменения. Другие транзакции не могут изменить или заблокировать строку.

FOR SHARE: Блокирует строку для чтения. Другие транзакции могут читать строку, но не могут изменять её.

FOR NO KEY UPDATE: Блокирует строку для изменения, но разрешает блокировку FOR KEY SHARE.

Пример блокировки строки:

sql
Copy
SELECT * FROM my_table WHERE id = 1 FOR UPDATE;
4. Когда используются блокировки?
Конфликтующие операции: Например, две транзакции пытаются изменить одну и ту же строку.

Обеспечение целостности данных: Например, блокировка таблицы при изменении её структуры (ALTER TABLE).

Ручное управление: Когда разработчик хочет явно контролировать доступ к данным.

5. Примеры использования блокировок
a) Блокировка таблицы
sql
Copy
BEGIN;
LOCK TABLE my_table IN EXCLUSIVE MODE;
-- Выполнение операций с таблицей
COMMIT;
b) Блокировка строки
sql
Copy
BEGIN;
SELECT * FROM my_table WHERE id = 1 FOR UPDATE;
-- Изменение строки
UPDATE my_table SET column = 'value' WHERE id = 1;
COMMIT;
6. Блокировки и производительность
Блокировки могут приводить к блокировкам (deadlocks), если две транзакции пытаются заблокировать одни и те же ресурсы в разном порядке.

Чем строже блокировка, тем выше вероятность снижения производительности из-за ожидания.

7. Как PostgreSQL управляет блокировками?
Мониторинг блокировок: PostgreSQL предоставляет системные представления, такие как pg_locks, для мониторинга текущих блокировок.

Автоматическое разрешение конфликтов: PostgreSQL автоматически обнаруживает и разрешает deadlocks, откатывая одну из транзакций.

Пример запроса для просмотра текущих блокировок:

sql
Copy
SELECT * FROM pg_locks;
8. Блокировки и изоляция
Блокировки и уровни изоляции тесно связаны:

Уровень изоляции определяет, какие аномалии должны быть предотвращены.

Блокировки обеспечивают механизм для реализации уровней изоляции.

Например, уровень изоляции Serializable использует строгие блокировки для предотвращения всех аномалий.

9. Рекомендации по использованию блокировок
Используйте блокировки только при необходимости.

Старайтесь минимизировать время удержания блокировок.

Избегайте deadlocks, блокируя ресурсы в одинаковом порядке.

Таким образом, изоляция в PostgreSQL не ограничивается только транзакциями. Блокировки таблиц и строк (кортежей) — это важные механизмы для управления параллельным доступом к данным и обеспечения их согласованности.









